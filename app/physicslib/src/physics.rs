/* automatically generated by rust-bindgen 0.61.0 */

pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"4.2.0\0";
pub const __NEWLIB__: u32 = 4;
pub const __NEWLIB_MINOR__: u32 = 2;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 200112;
pub const _POSIX_TIMERS: u32 = 1;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const TPE_FRACTIONS_PER_UNIT: u32 = 512;
pub const TPE_F: u32 = 512;
pub const TPE_JOINT_SIZE_MULTIPLIER: u32 = 32;
pub const TPE_INFINITY: u32 = 2147483647;
pub const TPE_APPROXIMATE_LENGTH: u32 = 0;
pub const TPE_LOW_SPEED: u32 = 30;
pub const TPE_RESHAPE_TENSION_LIMIT: u32 = 20;
pub const TPE_RESHAPE_ITERATIONS: u32 = 3;
pub const TPE_DEACTIVATE_AFTER: u32 = 128;
pub const TPE_LIGHT_DEACTIVATION: u32 = 116;
pub const TPE_TENSION_ACCELERATION_DIVIDER: u32 = 32;
pub const TPE_TENSION_ACCELERATION_THRESHOLD: u32 = 5;
pub const TPE_TENSION_GREATER_ACCELERATION_THRESHOLD: u32 = 15;
pub const TPE_COLLISION_RESOLUTION_ITERATIONS: u32 = 16;
pub const TPE_COLLISION_RESOLUTION_MARGIN: u32 = 8;
pub const TPE_NONROTATING_COLLISION_RESOLVE_ATTEMPTS: u32 = 8;
pub const TPE_APPROXIMATE_NET_SPEED: u32 = 1;
pub const TPE_BODY_FLAG_DEACTIVATED: u32 = 1;
pub const TPE_BODY_FLAG_NONROTATING: u32 = 2;
pub const TPE_BODY_FLAG_DISABLED: u32 = 4;
pub const TPE_BODY_FLAG_SOFT: u32 = 8;
pub const TPE_BODY_FLAG_SIMPLE_CONN: u32 = 16;
pub const TPE_BODY_FLAG_ALWAYS_ACTIVE: u32 = 32;
pub const TPE_DEBUG_COLOR_CONNECTION: u32 = 0;
pub const TPE_DEBUG_COLOR_JOINT: u32 = 1;
pub const TPE_DEBUG_COLOR_ENVIRONMENT: u32 = 2;
pub const TPE_DEBUG_COLOR_INACTIVE: u32 = 3;
pub const ANTI_OVERFLOW: u32 = 25000;
pub const _PI2: u32 = 5053;
pub const Z_LIMIT: u32 = 250;
pub const SEGS: u32 = 16;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __int_least8_t = ::libc::c_schar;
pub type __uint_least8_t = ::libc::c_uchar;
pub type __int_least16_t = ::libc::c_short;
pub type __uint_least16_t = ::libc::c_ushort;
pub type __int_least32_t = ::libc::c_int;
pub type __uint_least32_t = ::libc::c_uint;
pub type __int_least64_t = ::libc::c_longlong;
pub type __uint_least64_t = ::libc::c_ulonglong;
pub type __intmax_t = ::libc::c_longlong;
pub type __uintmax_t = ::libc::c_ulonglong;
pub type __intptr_t = ::libc::c_long;
pub type __uintptr_t = ::libc::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::libc::c_schar;
pub type uint_fast8_t = ::libc::c_uchar;
pub type int_fast16_t = ::libc::c_short;
pub type uint_fast16_t = ::libc::c_ushort;
pub type int_fast32_t = ::libc::c_int;
pub type uint_fast32_t = ::libc::c_uint;
pub type int_fast64_t = ::libc::c_longlong;
pub type uint_fast64_t = ::libc::c_ulonglong;
pub type TPE_Unit = i32;
pub type TPE_UnitReduced = i16;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPE_Vec3 {
    pub x: TPE_Unit,
    pub y: TPE_Unit,
    pub z: TPE_Unit,
}
extern "C" {
    #[doc = " Keeps given point within specified axis-aligned box. This can be used e.g."]
    #[doc = "to smooth rendered movement of jittering physics bodies."]
    pub fn TPE_vec3KeepWithinBox(
        point: TPE_Vec3,
        boxCenter: TPE_Vec3,
        boxMaxVect: TPE_Vec3,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3KeepWithinDistanceBand(
        point: TPE_Vec3,
        center: TPE_Vec3,
        minDistance: TPE_Unit,
        maxDistance: TPE_Unit,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3(x: TPE_Unit, y: TPE_Unit, z: TPE_Unit) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Minus(v1: TPE_Vec3, v2: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Plus(v1: TPE_Vec3, v2: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Cross(v1: TPE_Vec3, v2: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Project(v: TPE_Vec3, base: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3ProjectNormalized(v: TPE_Vec3, baseNormalized: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Times(v: TPE_Vec3, units: TPE_Unit) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3TimesPlain(v: TPE_Vec3, q: TPE_Unit) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Normalized(v: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Dot(v1: TPE_Vec3, v2: TPE_Vec3) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_vec3Len(v: TPE_Vec3) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_vec3LenApprox(v: TPE_Vec3) -> TPE_Unit;
}
extern "C" {
    #[doc = " Returns an angle in TPE_Units (see angle conventions) of a 2D vector with"]
    #[doc = "the X axis, CCW."]
    pub fn TPE_vec2Angle(x: TPE_Unit, y: TPE_Unit) -> TPE_Unit;
}
extern "C" {
    #[doc = " Keeps given value within specified range. This can be used e.g. for movement"]
    #[doc = "smoothing."]
    pub fn TPE_keepInRange(x: TPE_Unit, xMin: TPE_Unit, xMax: TPE_Unit) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_sqrt(x: TPE_Unit) -> TPE_Unit;
}
extern "C" {
    #[doc = " Compute sine, TPE_FRACTIONS_PER_UNIT as argument corresponds to 2 * PI"]
    #[doc = "radians. Returns a number from -TPE_FRACTIONS_PER_UNIT to"]
    #[doc = "TPE_FRACTIONS_PER_UNIT."]
    pub fn TPE_sin(x: TPE_Unit) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_cos(x: TPE_Unit) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_atan(x: TPE_Unit) -> TPE_Unit;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPE_Joint {
    pub position: TPE_Vec3,
    #[doc = "< not TPE_Vec3 to save size"]
    pub velocity: [TPE_UnitReduced; 3usize],
    #[doc = "< size (radius, ...), for saving space divided by"]
    #[doc = "TPE_JOINT_SIZE_MULTIPLIER"]
    pub sizeDivided: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPE_Connection {
    pub joint1: u8,
    pub joint2: u8,
    #[doc = "< connection's preferred length, uint16_t saves space"]
    pub length: u16,
}
#[doc = " Function used for defining static environment, working similarly to an SDF"]
#[doc = "(signed distance function). The parameters are: 3D point P, max distance D."]
#[doc = "The function should behave like this: if P is inside the solid environment"]
#[doc = "volume, P will be returned; otherwise closest point (by Euclidean distance) to"]
#[doc = "the solid environment volume from P will be returned, except for a case when"]
#[doc = "this closest point would be further away than D, in which case any arbitrary"]
#[doc = "point further away than D may be returned (this allows for optimizations)."]
pub type TPE_ClosestPointFunction =
    ::core::option::Option<unsafe extern "C" fn(arg1: TPE_Vec3, arg2: TPE_Unit) -> TPE_Vec3>;
#[doc = " Function that can be used as a joint-joint or joint-environment collision"]
#[doc = "callback, parameters are following: body1 index, joint1 index, body2 index,"]
#[doc = "joint2 index, collision world position. If body1 index is the same as body1"]
#[doc = "index, then collision type is body-environment, otherwise it is body-body"]
#[doc = "type. The function has to return either 1 if the collision is to be allowed"]
#[doc = "or 0 if it is to be discarded. This can besides others be used to disable"]
#[doc = "collisions between some bodies."]
pub type TPE_CollisionCallback = ::core::option::Option<
    unsafe extern "C" fn(arg1: u16, arg2: u16, arg3: u16, arg4: u16, arg5: TPE_Vec3) -> u8,
>;
#[doc = " Function used by the debug drawing functions to draw individual pixels to"]
#[doc = "the screen. The parameters are following: pixel x, pixel y, pixel color."]
pub type TPE_DebugDrawFunction =
    ::core::option::Option<unsafe extern "C" fn(arg1: u16, arg2: u16, arg3: u8)>;
#[doc = " Physics body made of spheres (each of same weight but possibly different"]
#[doc = "radia) connected by elastic springs."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPE_Body {
    pub joints: *mut TPE_Joint,
    pub jointCount: u8,
    pub connections: *mut TPE_Connection,
    pub connectionCount: u8,
    #[doc = "< mass of a single joint"]
    pub jointMass: TPE_UnitReduced,
    #[doc = "< friction of each joint"]
    pub friction: TPE_UnitReduced,
    #[doc = "< elasticity of each joint"]
    pub elasticity: TPE_UnitReduced,
    pub flags: u8,
    pub deactivateCount: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TPE_World {
    pub bodies: *mut TPE_Body,
    pub bodyCount: u16,
    pub environmentFunction: TPE_ClosestPointFunction,
    pub collisionCallback: TPE_CollisionCallback,
}
extern "C" {
    #[doc = " Tests the mathematical validity of given closest point function (function"]
    #[doc = "representing the physics environment), i.e. whether for example approaching"]
    #[doc = "some closest point in a straight line keeps approximately the same closest"]
    #[doc = "point. Note that this function may take a long time to complete, especially"]
    #[doc = "with higher gridResolution values and more complex environment functions. You"]
    #[doc = "should use this function to test your environment function, especially if you"]
    #[doc = "create functions for your own shapes etc. The cornerFrom and cornerTo points"]
    #[doc = "are corners of an axis-aligned box within which testing will take place,"]
    #[doc = "gridResolution defines numbers of points (i.e. step length) along each"]
    #[doc = "dimension to test (recommended e.g. 64), allowedError says error within which"]
    #[doc = "points will be considered the same (recommended range approx. 10 to 200). If"]
    #[doc = "testing is successful, 1 is returned, otherwise 0 is returned and the point"]
    #[doc = "around which error was detected is returned in errorPoint (unless the pointer"]
    #[doc = "is 0 in which case it is ignored)."]
    pub fn TPE_testClosestPointFunction(
        f: TPE_ClosestPointFunction,
        cornerFrom: TPE_Vec3,
        cornerTo: TPE_Vec3,
        gridResolution: u8,
        allowedError: TPE_UnitReduced,
        errorPoint: *mut TPE_Vec3,
    ) -> u8;
}
extern "C" {
    pub fn TPE_bodyInit(
        body: *mut TPE_Body,
        joints: *mut TPE_Joint,
        jointCount: u8,
        connections: *mut TPE_Connection,
        connectionCount: u8,
        mass: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_worldInit(
        world: *mut TPE_World,
        bodies: *mut TPE_Body,
        bodyCount: u16,
        environmentFunction: TPE_ClosestPointFunction,
    );
}
extern "C" {
    #[doc = " Gets orientation (rotation) of a body from a position of three of its"]
    #[doc = "joints. The vector from joint1 to joint2 is considered the body's forward"]
    #[doc = "direction, the vector from joint1 to joint3 its right direction. The returned"]
    #[doc = "rotation is in Euler angles (see rotation conventions)."]
    pub fn TPE_bodyGetRotation(
        body: *const TPE_Body,
        joint1: u16,
        joint2: u16,
        joint3: u16,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_vec3Normalize(v: *mut TPE_Vec3);
}
extern "C" {
    #[doc = " Rotates a 3D point by given Euler angle rotation (see rotation"]
    #[doc = "conventions)."]
    pub fn TPE_pointRotate(point: TPE_Vec3, rotation: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Returns an inverse rotation to given rotation, in Euler angles (see rotation"]
    #[doc = "conventions)."]
    pub fn TPE_rotationInverse(rotation: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Rotates a rotation specified in Euler angles by given axis + angle (see"]
    #[doc = "rotation conventions). Returns a rotation in Eurler angles."]
    pub fn TPE_rotationRotateByAxis(rotation: TPE_Vec3, rotationByAxis: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Computes the formula of a 1D collision of rigid bodies."]
    pub fn TPE_getVelocitiesAfterCollision(
        v1: *mut TPE_Unit,
        v2: *mut TPE_Unit,
        m1: TPE_Unit,
        m2: TPE_Unit,
        elasticity: TPE_Unit,
    );
}
extern "C" {
    #[doc = " Computes orientation/rotation (see docs for orientation format) from two"]
    #[doc = "vectors (which should be at least close to being perpendicular and do NOT"]
    #[doc = "need to be normalized). This can be used to determine orientation of a body"]
    #[doc = "from a relative position of its joints."]
    pub fn TPE_rotationFromVecs(forward: TPE_Vec3, right: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_joint(position: TPE_Vec3, size: TPE_Unit) -> TPE_Joint;
}
extern "C" {
    #[doc = " Mostly for internal use, resolves a potential collision of two joints in a"]
    #[doc = "way that keeps the joints outside provided environment (if the function"]
    #[doc = "pointer is not 0). Returns 1 if joints collided or 0 otherwise."]
    pub fn TPE_jointsResolveCollision(
        j1: *mut TPE_Joint,
        j2: *mut TPE_Joint,
        mass1: TPE_Unit,
        mass2: TPE_Unit,
        elasticity: TPE_Unit,
        friction: TPE_Unit,
        env: TPE_ClosestPointFunction,
    ) -> u8;
}
extern "C" {
    #[doc = " Mostly for internal use, tests and potentially resolves a collision between"]
    #[doc = "a joint and environment, returns 0 if no collision happened, 1 if it happened"]
    #[doc = "and was resolved normally and 2 if it couldn't be resolved normally."]
    pub fn TPE_jointEnvironmentResolveCollision(
        joint: *mut TPE_Joint,
        elasticity: TPE_Unit,
        friction: TPE_Unit,
        env: TPE_ClosestPointFunction,
    ) -> u8;
}
extern "C" {
    #[doc = " Tests whether a body is currently colliding with the environment."]
    pub fn TPE_bodyEnvironmentCollide(body: *const TPE_Body, env: TPE_ClosestPointFunction) -> u8;
}
extern "C" {
    #[doc = " Mostly for internal use, tests and potentially resolves a collision of a"]
    #[doc = "body with the environment, returns 1 if collision happened or 0 otherwise."]
    pub fn TPE_bodyEnvironmentResolveCollision(
        body: *mut TPE_Body,
        env: TPE_ClosestPointFunction,
    ) -> u8;
}
extern "C" {
    pub fn TPE_bodyGetLinearVelocity(body: *const TPE_Body) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Computes the minimum bounding box of given body."]
    pub fn TPE_bodyGetAABB(body: *const TPE_Body, vMin: *mut TPE_Vec3, vMax: *mut TPE_Vec3);
}
extern "C" {
    #[doc = " Computes a bounding sphere of a body which is not minimal but faster to"]
    #[doc = "compute than the minimum bounding sphere."]
    pub fn TPE_bodyGetFastBSphere(
        body: *const TPE_Body,
        center: *mut TPE_Vec3,
        radius: *mut TPE_Unit,
    );
}
extern "C" {
    #[doc = " Computes the minimum bounding sphere of a body (there is another function"]
    #[doc = "for a faster approximate bounding sphere)."]
    pub fn TPE_bodyGetBSphere(body: *const TPE_Body, center: *mut TPE_Vec3, radius: *mut TPE_Unit);
}
extern "C" {
    pub fn TPE_checkOverlapAABB(
        v1Min: TPE_Vec3,
        v1Max: TPE_Vec3,
        v2Min: TPE_Vec3,
        v2Max: TPE_Vec3,
    ) -> u8;
}
extern "C" {
    #[doc = " Mostly for internal use, checks and potentiall resolves collision of two"]
    #[doc = "bodies so as to keep them outside given environment. Returns 1 if collision"]
    #[doc = "happened or 0 otherwise."]
    pub fn TPE_bodiesResolveCollision(
        b1: *mut TPE_Body,
        b2: *mut TPE_Body,
        env: TPE_ClosestPointFunction,
    ) -> u8;
}
extern "C" {
    #[doc = " Pins a joint of a body to specified location in space (sets its location"]
    #[doc = "and zeros its velocity)."]
    pub fn TPE_jointPin(joint: *mut TPE_Joint, position: TPE_Vec3);
}
extern "C" {
    #[doc = " \"Fakes\" a rotation of a moving sphere by rotating it in the direction of"]
    #[doc = "its movement; this can create the illusion of the sphere actually rotating"]
    #[doc = "due to friction even if the physics sphere object (a body with a single joint)"]
    #[doc = "isn't rotating at all. Returns a rotation in the \"about axis\" format (see"]
    #[doc = "library conventions)."]
    pub fn TPE_fakeSphereRotation(
        position1: TPE_Vec3,
        position2: TPE_Vec3,
        radius: TPE_Unit,
    ) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Casts a ray against environment and returns the closest hit of a surface. If"]
    #[doc = "no surface was hit, a vector with all elements equal to TPE_INFINITY will be"]
    #[doc = "returned. The function internally works differently for outside rays (rays"]
    #[doc = "cast from the outside of the environment) and inside rays. Outside rays can"]
    #[doc = "be traced with raymarching and will be processed very quickly and precisely;"]
    #[doc = "in this case if any intersection is found, the function will try to return a"]
    #[doc = "point outside (not guaranteed) the environment that's just in front of the hit"]
    #[doc = "surface. Inside rays are difficult and slow to trace because environment"]
    #[doc = "function won't provide distance, so the results aren't guaranteed to be"]
    #[doc = "precise (the ray may miss some intersections); here rays will be traced by"]
    #[doc = "given step (insideStepSize) and eventually iterated a bit towards the"]
    #[doc = "intersection -- if any intersection is found, the function will try to return"]
    #[doc = "a point inside (not guaranteed) the environment just before the hit"]
    #[doc = "surface."]
    pub fn TPE_castEnvironmentRay(
        rayPos: TPE_Vec3,
        rayDir: TPE_Vec3,
        environment: TPE_ClosestPointFunction,
        insideStepSize: TPE_Unit,
        rayMarchMaxStep: TPE_Unit,
        maxSteps: u32,
    ) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Casts a ray against bodies in a world (ignoring the environment), returns"]
    #[doc = "the position of the closest hit as well as the hit body's index in bodyIndex"]
    #[doc = "(unless the bodyIndex pointer is 0 in which case it is ignored). Similarly"]
    #[doc = "with jointIndex. If no hit is found a vector with all elements equal to"]
    #[doc = "TPE_INFINITY will be returned and bodyIndex will be -1. A specific body can be"]
    #[doc = "excluded with excludeBody (negative value will just make this parameter"]
    #[doc = "ignored)."]
    pub fn TPE_castBodyRay(
        rayPos: TPE_Vec3,
        rayDir: TPE_Vec3,
        excludeBody: i16,
        world: *const TPE_World,
        bodyIndex: *mut i16,
        jointIndex: *mut i16,
    ) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Performs one step (tick, frame, ...) of the physics world simulation"]
    #[doc = "including updating positions and velocities of bodies, collision detection and"]
    #[doc = "resolution, possible reshaping or deactivation of inactive bodies etc. The"]
    #[doc = "time length of the step is relative to all other units but it's ideal if it is"]
    #[doc = "1/30th of a second."]
    pub fn TPE_worldStep(world: *mut TPE_World);
}
extern "C" {
    pub fn TPE_worldDeactivateAll(world: *mut TPE_World);
}
extern "C" {
    pub fn TPE_worldActivateAll(world: *mut TPE_World);
}
extern "C" {
    pub fn TPE_worldGetNetSpeed(world: *const TPE_World) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_bodyGetNetSpeed(body: *const TPE_Body) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_bodyGetAverageSpeed(body: *const TPE_Body) -> TPE_Unit;
}
extern "C" {
    pub fn TPE_bodyMultiplyNetSpeed(body: *mut TPE_Body, factor: TPE_Unit);
}
extern "C" {
    pub fn TPE_bodyLimitAverageSpeed(body: *mut TPE_Body, speedMin: TPE_Unit, speedMax: TPE_Unit);
}
extern "C" {
    #[doc = " Deactivates a body (puts it to sleep until another collision or force wake"]
    #[doc = "up)."]
    pub fn TPE_bodyDeactivate(body: *mut TPE_Body);
}
extern "C" {
    #[doc = " Attempts to shift the joints of a soft body so that the tension of all"]
    #[doc = "springs becomes zero while keeping the joints near their current position."]
    #[doc = "This function performs one iteration of the equalizing algorithm and doesn't"]
    #[doc = "guarantee a perfect solution, it may help to run multiple iterations (call"]
    #[doc = "this function multiple times)."]
    pub fn TPE_bodyReshape(body: *mut TPE_Body, environmentFunction: TPE_ClosestPointFunction);
}
extern "C" {
    #[doc = " Mostly for internal use, performs some \"magic\" on body connections, mainly"]
    #[doc = "cancelling out of velocities going against each other and also applying"]
    #[doc = "connection friction in soft bodies. The strong parameter indicates if the"]
    #[doc = "body is soft or not."]
    pub fn TPE_bodyCancelOutVelocities(body: *mut TPE_Body, strong: u8);
}
extern "C" {
    #[doc = " Moves a body by certain offset."]
    pub fn TPE_bodyMoveBy(body: *mut TPE_Body, offset: TPE_Vec3);
}
extern "C" {
    #[doc = " Moves a body (its center of mass) to given position."]
    pub fn TPE_bodyMoveTo(body: *mut TPE_Body, position: TPE_Vec3);
}
extern "C" {
    #[doc = " Zeros velocities of all soft body joints."]
    pub fn TPE_bodyStop(body: *mut TPE_Body);
}
extern "C" {
    pub fn TPE_bodyActivate(body: *mut TPE_Body);
}
extern "C" {
    #[doc = " Adds velocity to a soft body."]
    pub fn TPE_bodyAccelerate(body: *mut TPE_Body, velocity: TPE_Vec3);
}
extern "C" {
    pub fn TPE_bodyApplyGravity(body: *mut TPE_Body, downwardsAccel: TPE_Unit);
}
extern "C" {
    #[doc = " Adds angular velocity to a soft body. The rotation vector specifies the axis"]
    #[doc = "of rotation by its direction and angular velocity by its magnitude (magnitude"]
    #[doc = "of TPE_FRACTIONS_PER_UNIT will add linear velocity of TPE_FRACTIONS_PER_UNIT"]
    #[doc = "per tick to a point in the distance of TPE_FRACTIONS_PER_UNIT from the"]
    #[doc = "rotation axis)."]
    pub fn TPE_bodySpin(body: *mut TPE_Body, rotation: TPE_Vec3);
}
extern "C" {
    #[doc = " Same as TPE_bodySpin but additionally allows to specify the center of"]
    #[doc = "the spin."]
    pub fn TPE_bodySpinWithCenter(body: *mut TPE_Body, rotation: TPE_Vec3, center: TPE_Vec3);
}
extern "C" {
    #[doc = " Instantly rotates a body about an axis (see library conventions for"]
    #[doc = "the rotation format)."]
    pub fn TPE_bodyRotateByAxis(body: *mut TPE_Body, rotation: TPE_Vec3);
}
extern "C" {
    #[doc = " Computes the center of mass of a body. This averages the position of all"]
    #[doc = "joints; note that if you need, you may estimate the center of the body faster,"]
    #[doc = "e.g. by taking a position of a single \"center joint\", or averaging just 2"]
    #[doc = "extreme points."]
    pub fn TPE_bodyGetCenterOfMass(body: *const TPE_Body) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Draws a debug view of a 3D physics world using a provided pixel drawing"]
    #[doc = "function. This can be used to overlay a simple visualization of the physics"]
    #[doc = "objects to your main render, to spot exact borders of objects etc. The"]
    #[doc = "function draws simple dotted lines and circles with different \"colors\" for"]
    #[doc = "different types of objects (joints, connections, environemnt). camPos, camRot"]
    #[doc = "and camView should match the camera settings of your main renderer. CamView.x"]
    #[doc = "is horizontal resolution in pixels, camView.y is the vertical resolution,"]
    #[doc = "CamView.z says the camera focal length (~FOV) in TPE_Units (0 means"]
    #[doc = "orthographic projection). envGridRes is the resolution of an environment probe"]
    #[doc = "grid (the function will probe points in space and draw borders of the physics"]
    #[doc = "environemnt), envGridSize is the size (int TPE_Units) of the grid cell. Note"]
    #[doc = "the function may be slow (reducing envGridRes can help, workable value can be"]
    #[doc = "e.g. 16)."]
    pub fn TPE_worldDebugDraw(
        world: *mut TPE_World,
        drawFunc: TPE_DebugDrawFunction,
        camPos: TPE_Vec3,
        camRot: TPE_Vec3,
        camView: TPE_Vec3,
        envGridRes: u16,
        envGridSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_jointHash(joint: *const TPE_Joint) -> u32;
}
extern "C" {
    pub fn TPE_connectionHash(connection: *const TPE_Connection) -> u32;
}
extern "C" {
    pub fn TPE_bodyHash(body: *const TPE_Body) -> u32;
}
extern "C" {
    #[doc = " Computes 32 bit hash of the world, useful for checking if two states of the"]
    #[doc = "world differ. The function takes into account most of the relevant state but"]
    #[doc = "possibly not all of it, for details check the code."]
    pub fn TPE_worldHash(world: *const TPE_World) -> u32;
}
extern "C" {
    pub fn TPE_makeBox(
        joints: *mut TPE_Joint,
        connections: *mut TPE_Connection,
        width: TPE_Unit,
        depth: TPE_Unit,
        height: TPE_Unit,
        jointSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_makeCenterBox(
        joints: *mut TPE_Joint,
        connections: *mut TPE_Connection,
        width: TPE_Unit,
        depth: TPE_Unit,
        height: TPE_Unit,
        jointSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_makeRect(
        joints: *mut TPE_Joint,
        connections: *mut TPE_Connection,
        width: TPE_Unit,
        depth: TPE_Unit,
        jointSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_makeTriangle(
        joints: *mut TPE_Joint,
        connections: *mut TPE_Connection,
        sideLength: TPE_Unit,
        jointSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_makeCenterRect(
        joints: *mut TPE_Joint,
        connections: *mut TPE_Connection,
        width: TPE_Unit,
        depth: TPE_Unit,
        jointSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_makeCenterRectFull(
        joints: *mut TPE_Joint,
        connections: *mut TPE_Connection,
        width: TPE_Unit,
        depth: TPE_Unit,
        jointSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_make2Line(
        joints: *mut TPE_Joint,
        connections: *mut TPE_Connection,
        length: TPE_Unit,
        jointSize: TPE_Unit,
    );
}
extern "C" {
    pub fn TPE_envAABoxInside(point: TPE_Vec3, center: TPE_Vec3, size: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envAABox(point: TPE_Vec3, center: TPE_Vec3, maxCornerVec: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envBox(
        point: TPE_Vec3,
        center: TPE_Vec3,
        maxCornerVec: TPE_Vec3,
        rotation: TPE_Vec3,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envSphere(point: TPE_Vec3, center: TPE_Vec3, radius: TPE_Unit) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envSphereInside(point: TPE_Vec3, center: TPE_Vec3, radius: TPE_Unit) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envHalfPlane(point: TPE_Vec3, center: TPE_Vec3, normal: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envGround(point: TPE_Vec3, height: TPE_Unit) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envInfiniteCylinder(
        point: TPE_Vec3,
        center: TPE_Vec3,
        direction: TPE_Vec3,
        radius: TPE_Unit,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envCylinder(
        point: TPE_Vec3,
        center: TPE_Vec3,
        direction: TPE_Vec3,
        radius: TPE_Unit,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envCone(
        point: TPE_Vec3,
        center: TPE_Vec3,
        direction: TPE_Vec3,
        radius: TPE_Unit,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envLineSegment(point: TPE_Vec3, a: TPE_Vec3, b: TPE_Vec3) -> TPE_Vec3;
}
extern "C" {
    pub fn TPE_envHeightmap(
        point: TPE_Vec3,
        center: TPE_Vec3,
        gridSize: TPE_Unit,
        heightFunction: ::core::option::Option<unsafe extern "C" fn(x: i32, y: i32) -> TPE_Unit>,
        maxDist: TPE_Unit,
    ) -> TPE_Vec3;
}
extern "C" {
    #[doc = " Environment function for triagnular prism, e.g. for ramps. The sides array"]
    #[doc = "contains three 2D coordinates of points of the triangle in given plane with"]
    #[doc = "respect to the center. WARNING: the points must be specified in counter"]
    #[doc = "clowckwise direction! The direction var specified axis direction (0, 1 or"]
    #[doc = "2)."]
    pub fn TPE_envAATriPrism(
        point: TPE_Vec3,
        center: TPE_Vec3,
        sides: *const TPE_Unit,
        depth: TPE_Unit,
        direction: u8,
    ) -> TPE_Vec3;
}
extern "C" {
    pub static mut _TPE_body1Index: u16;
}
extern "C" {
    pub static mut _TPE_body2Index: u16;
}
extern "C" {
    pub static mut _TPE_joint1Index: u16;
}
extern "C" {
    pub static mut _TPE_joint2Index: u16;
}
extern "C" {
    pub static mut _TPE_collisionCallback: TPE_CollisionCallback;
}
extern "C" {
    pub fn _TPE_rotateByAxis(p: TPE_Vec3, axisNormalized: TPE_Vec3, angle: TPE_Unit) -> TPE_Vec3;
}
extern "C" {
    pub fn _TPE_bodyNonrotatingJointCollided(
        b: *mut TPE_Body,
        jointIndex: i16,
        origPos: TPE_Vec3,
        success: u8,
    );
}
extern "C" {
    pub fn _TPE_vec2Rotate(x: *mut TPE_Unit, y: *mut TPE_Unit, angle: TPE_Unit);
}
extern "C" {
    pub fn _TPE_project3DPoint(
        p: TPE_Vec3,
        camPos: TPE_Vec3,
        camRot: TPE_Vec3,
        camView: TPE_Vec3,
    ) -> TPE_Vec3;
}
extern "C" {
    pub fn _TPE_drawDebugPixel(
        x: TPE_Unit,
        y: TPE_Unit,
        w: TPE_Unit,
        h: TPE_Unit,
        c: u8,
        f: TPE_DebugDrawFunction,
    );
}
extern "C" {
    pub fn _TPE_hash(n: u32) -> u32;
}
